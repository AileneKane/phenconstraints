strftime(date_expmin, format = "%j")
as.numeric(strftime(date_expmin, format = "%j"))
as.numeric(strftime(date_expmin, format = "%j"))-as.numeric(strftime(date_expmax, format = "%j"))
min(as.numeric(strftime(date_expmin, format = "%j"))-as.numeric(strftime(date_expmax, format = "%j")))#s
photop_all$time[i]<-min(as.numeric(strftime(date_expmin, format = "%j"))-as.numeric(strftime(date_expmax, format = "%j")))#shift in days between date(s) of min daylength and max daylength in exp
#a different approach that i am abandoning for now:
#delta
photop_all$daylength<-paste(photop_all$daylength_min,photop_all$daylength_max, sep="-")
photop_all$delta<-photop_all$daylength_max-photop_all$daylength_min
photop_all$space<-""
photop_all$time<-""
for(i in 1:length(photop_all$lat)){
photos<-daylength(photop_all$lat[i], c(355:365,1:172))
date<-strptime(c(355:365,1:172), format = "%j")
date_expmin<-date[which(round(photos, digits=1)==round(photop_all$daylength_min[i], digits
=1))]
date_expmax<-date[which(round(photos, digits=1)==round(photop_all$daylength_max[i], digits
=1))]
#when there is no date that matches the maximum date , choose the closest one, as long as it is within .5 hours
if(length(date_expmax)==0)   {
mindiff<-min(abs(photop_all$daylength_max[i]-photos))
if(mindiff<0.5){date_expmax<-date[which(photop_all$daylength_max[i]-photos==min(abs(photop_all$daylength_max[i]-photos)))]
}else {
date_expmax<-NA
}
}
#when there is no date that matches the minimum date , choose the closest one, as long as it is within .5 hours
if(length(date_expmin)==0)   {
mindiff<-min(abs(photop_all$daylength_min[i]-photos))
if(mindiff<0.5){date_expmin<-date[which(abs(photop_all$daylength_min[i]-photos)==min(abs(photop_all$daylength_min[i]-photos)))]
}else {
date_expmin<-NA
}
}
maxdelta_temp<-max(photos)-min(photos)#maximum difference in daylength at lat[i] (difference in daylength between summer solcstice and winter solcstice
if(maxdelta_temp<photop_all$delta[i]){photop_all$time[i]<-"exceeds range"}
else  {
photop_all$time[i]<-min(as.numeric(strftime(date_expmin, format = "%j"))-as.numeric(strftime(date_expmax, format = "%j")))#shift in days between date(s) of min daylength and max daylength in exp
#a different approach that i am abandoning for now:
#delta_mar21<-daylength(photop_all$lat[i],80)-daylength(photop_all$lat[i], c(355:365,1:172))
#delta_jun21<-daylength(photop_all$lat[i],172)-daylength(photop_all$lat[i], c(355:365,1:172))
#assume march 21, change in daylength for each day earlier than that back to winter solcistice
#need to figure out the spatial shift thing- try different latitudes and find matching daylength to min and max on the same date
#In 100 years, with spatial shifts of ~6km ( or ~0.05 degrees) per decade (0.5 deg total) poleward as has been observed (Parmesan 2006)- this is a low end
#photos_spat<-daylength(photop_all$lat[i]+0.5, 1:181)
#photop$space[i]<-
}
min(as.numeric(strftime(date_expmin, format = "%j"))-as.numeric(strftime(date_expmax, format = "%j")))#
if(maxdelta_temp<photop_all$delta[i]){photop_all$time[i]<-"exceeds range"}
else  {
photop_all$time[i]<-min(as.numeric(strftime(date_expmin, format = "%j"))-as.numeric(strftime(date_expmax, format = "%j")))#shift in days between date(s) of min daylength and max daylength in exp
#a different approach that i am abandoning for now:
#delta_mar21<-daylength(photop_all$lat[i],80)-daylength(photop_all$lat[i], c(355:365,1:172))
#delta_jun21<-daylength(photop_all$lat[i],172)-daylength(photop_all$lat[i], c(355:365,1:172))
#assume march 21, change in daylength for each day earlier than that back to winter solcistice
#need to figure out the spatial shift thing- try different latitudes and find matching daylength to min and max on the same date
#In 100 years, with spatial shifts of ~6km ( or ~0.05 degrees) per decade (0.5 deg total) poleward as has been observed (Parmesan 2006)- this is a low end
#photos_spat<-daylength(photop_all$lat[i]+0.5, 1:181)
#photop$space[i]<-
}
photop_all$time
photop_all<-join(photop_min,photop_max, by=c("Group.1", "Group.2", "Group.3"), match="all")
colnames(photop_all)[1:3]<-c("study","lat","long")
#remove studies that only have one photoperiod treatment
photop_all<-photop_all[-which(photop_all$daylength_min==photop_all$daylength_max),]
#remove studdies with no data for daylength
photop_all<-photop_all[-which(is.na(photop_all$daylength_min)),]
#combine min and max into one column
photop_all$daylength<-paste(photop_all$daylength_min,photop_all$daylength_max, sep="-")
photop_all$delta<-photop_all$daylength_max-photop_all$daylength_min
photop_all$space<-""
photop_all$time<-""
for(i in 1:length(photop_all$lat)){
photos<-daylength(photop_all$lat[i], c(355:365,1:172))
date<-strptime(c(355:365,1:172), format = "%j")
date_expmin<-date[which(round(photos, digits=1)==round(photop_all$daylength_min[i], digits
=1))]
date_expmax<-date[which(round(photos, digits=1)==round(photop_all$daylength_max[i], digits
=1))]
#when there is no date that matches the maximum date , choose the closest one, as long as it is within .5 hours
if(length(date_expmax)==0)   {
mindiff<-min(abs(photop_all$daylength_max[i]-photos))
if(mindiff<0.5){date_expmax<-date[which(photop_all$daylength_max[i]-photos==min(abs(photop_all$daylength_max[i]-photos)))]
}else {
date_expmax<-NA
}
}
#when there is no date that matches the minimum date , choose the closest one, as long as it is within .5 hours
if(length(date_expmin)==0)   {
mindiff<-min(abs(photop_all$daylength_min[i]-photos))
if(mindiff<0.5){date_expmin<-date[which(abs(photop_all$daylength_min[i]-photos)==min(abs(photop_all$daylength_min[i]-photos)))]
}else {
date_expmin<-NA
}
}
maxdelta_temp<-max(photos)-min(photos)#maximum difference in daylength at lat[i] (difference in daylength between summer solcstice and winter solcstice
if(maxdelta_temp<photop_all$delta[i]){photop_all$time[i]<-"exceeds range"}
else
photop_all$time[i]<-min(as.numeric(strftime(date_expmin, format = "%j"))-as.numeric(strftime(date_expmax, format = "%j")))#shift in days between date(s) of min daylength and max daylength in exp
#a different approach that i am ab#shift in days between date(s) of min daylength and max daylength in exp
#a different approach that i am abandoning for now:
#delta_mar21<-daylength(photop_all$lat[i],80)-daylength(photop_all$lat[i], c(355:365,1:172))
#delta_jun21<-daylength(photop_all$lat[i],172)-daylength(photop_all$lat[i], c(355:365,1:172))
#assume march 21, change in daylength for each day earlier than that back to winter solcistice
#need to figure out the spatial shift thing- try different latitudes and find matching daylength to min and max on the same date
#In 100 years, with spatial shifts of ~6km ( or ~0.05 degrees) per decade (0.5 deg total) poleward as has been observed (Parmesan 2006)- this is a low end
#photos_spat<-daylength(photop_all$lat[i]+0.5, 1:181)
#photop$space[i]<-
}
photop_table<-subset(photop_all, select=c(study, lat, long,daylength,space,time))
i
photop_all$time
i=35
photos<-daylength(photop_all$lat[i], c(355:365,1:172))
photos
date<-strptime(c(355:365,1:172), format = "%j")
date
date_expmin
date_expmax
length(date_expmax)==0
date_expmax<-date[which(round(photos, digits=1)==round(photop_all$daylength_max[i], digits
=1))]
date_expmax
photos<-daylength(photop_all$lat[i], c(355:365,1:172))
date<-strptime(c(355:365,1:172), format = "%j")
date
date_expmin<-date[which(round(photos, digits=1)==round(photop_all$daylength_min[i], digits
=1))]
date_expmin
date_expmax<-date[which(round(photos, digits=1)==round(photop_all$daylength_max[i], digits
=1))]
date_expmax
length(date_expmax)==0
mindiff<-min(abs(photop_all$daylength_max[i]-photos))
if(mindiff<0.5){date_expmax<-date[which(photop_all$daylength_max[i]-photos==min(abs(photop_all$daylength_max[i]-photos)))]
}else {
date_expmax<-NA
}
mindiff
if(length(date_expmax)==0)   {
mindiff<-min(abs(photop_all$daylength_max[i]-photos))
if(mindiff<0.5){date_expmax<-date[which(photop_all$daylength_max[i]-photos==min(abs(photop_all$daylength_max[i]-photos)))]
}else {
date_expmax<-NA
}
}
date_expmax
date_expmax<-date[which(round(photos, digits=1)==round(photop_all$daylength_max[i], digits
=1))]
length(date_expmax)==0
mindiff<-min(abs(photop_all$daylength_max[i]-photos))
mindiff
mindiff<0.5
date_expmax<-date[which(photop_all$daylength_max[i]-photos==min(abs(photop_all$daylength_max[i]-photos)))
]
date_expmax
which(photop_all$daylength_max[i]
photop_all$daylength_max[i]-photos
min(abs(photop_all$daylength_max[i]-photos)))
which(photop_all$daylength_max[i]-photos==min(abs(photop_all$daylength_max[i]-photos)))
min(abs(photop_all$daylength_max[i]-photos))
photop_all$daylength_max[i]-photos
which(abs(photop_all$daylength_max[i]-photos)==min(abs(photop_all$daylength_max[i]-photos)))
date[which(abs(photop_all$daylength_max[i]-photos)==min(abs(photop_all$daylength_max[i]-photos)))]
date_expmin
(photop_all$daylength_min[i]
photop_all$daylength_min[i]
photop_all$daylength_max[i]
photos
photos<-daylength(photop_all$lat[i], c(355:365,1:172))
date<-strptime(c(355:365,1:172), format = "%j")
date_expmin<-date[which(round(photos, digits=1)==round(photop_all$daylength_min[i], digits
=1))]
date_expmax<-date[which(round(photos, digits=1)==round(photop_all$daylength_max[i], digits
=1))]
photop_all$daylength_max[i]
photos
photos<-daylength(photop_all$lat[i], c(355:365,1:172))
date<-strptime(c(355:365,1:172), format = "%j")
date_expmin<-date[which(round(photos, digits=1)==round(photop_all$daylength_min[i], digits
=1))]
date_expmax<-date[which(round(photos, digits=1)==round(photop_all$daylength_max[i], digits
=1))]
i
date_expmin
date_expmax
round(photos, digits=1)
round(photop_all$daylength_max[i], digits
=1))
round(photop_all$daylength_max[i], digits
=1)
mindiff<-min(abs(photop_all$daylength_max[i]-photos))
mindiff
min(abs(photop_all$daylength_max[i]-photos))
photop_all$daylength_max[i]-photos
mindiff
mindiff<0.5
date[which(abs(photop_all$daylength_max[i]-photos)==mindif)]
if(mindiff<0.5){date_expmax<-date[which(abs(photop_all$daylength_max[i]-photos)==mindiff)]
}
date_expmax
photop <- ospree %>% # start with the data frame
distinct(ID_daylengths, .keep_all = TRUE) %>% # establishing grouping variables
dplyr::select(datasetID, continent, provenance.lat, provenance.long, photoperiod_day)#growing or provenance lat/long?
photop<-photop[-which(photop$photoperiod_day=="ambient"),]
photop<-photop[-which(photop$photoperiod_day==""),]
photop<-photop[-which(photop$photoperiod_day=="constant"),]
#photop<-photop[-which(photop$photoperiod_day=="half in 16, half ambient(9.5-10.5)"),]#remove this on
photop
head(photop)
#need to add delta photoperiod, space, and time equivalents of these
#try instead columns for daylength (min, max) and spatial temporal can be the difference between these
#aggregate to get imn and max daylengths
photop_min<-aggregate(as.numeric(photop$photoperiod_day), by=list(photop$datasetID,photop$continent,photop$provenance.lat,photop$provenance.long), FUN=min)
photop_min
31+28+20
latshift<-seq(0,10,by=.1)
latshift
photos_spat<-daylength(photop_all$lat[i]+latshift, phendate)
#need to figure out the spatial shift thing- try different latitudes and find matching daylength to min and max on the same date. Eventually, date should be latitude-specific greenup date. For now, choose March 20 as a date.
#In 100 years, with spatial shifts of ~6km ( or ~0.05 degrees) per decade (0.5 deg total) poleward as has been observed (Parmesan 2006)- this is a low end
phendate<-79#march 20
latshift<-seq(0,10,by=.1)
photos_spat<-daylength(photop_all$lat[i]+latshift, phendate)
photos_spat
latshift<-seq(0,20,by=.1)
photos_spat<-daylength(photop_all$lat[i]+latshift, phendate)
expclim<-read.csv("../../Analyses/gddchill/expclim.wchillgdd.csv", header=TRUE)
setwd("/Users/aileneettinger/git/radcliffe/documents/expwarm")
expclim<-read.csv("../../Analyses/gddchill/expclim.wchillgdd.csv", header=TRUE)
exppheno<-read.csv("../../Analyses/exppheno.csv", header=TRUE)
treats<-read.csv("../../Analyses/treats_detail.csv", header=T)
#standard data wrangling to get expclim2 for climate analyses and expgdd for phenology analyses (with gddcrit)
source("../../Analyses/source/standard_mergesandwrangling.R")
#summarize climate data by plot (annual and seasonal temp, soil mois),
#merge in with expgdd file, and select out only sites with soil moisture and air temperature data, and remove NAs
source("../../Analyses/soilmoisture/climsum_byplot.R")
expgdd_bbd<-expgdd_subs[which(expgdd_subs$event=="bbd"),]#
expgdd_bbd$styear<-as.factor(expgdd_bbd$styear)
#Fit target warming model
smbbdmod_targt<-lmer(doy~target + (1|genus.species)+ (1|site/styear), REML=FALSE, data=expgdd_bbd)
library(lme4)
#Fit target warming model
smbbdmod_targt<-lmer(doy~target + (1|genus.species)+ (1|site/styear), REML=FALSE, data=expgdd_bbd)
#Fit a few other models and compare fit
#First, make temperature a more comparable scale to warming by relativising it to minimum agmin temp (or min agmax temp) across all studies
#subtract minimum agtmax to get it close to 0 warming to make scale more comparable to "target warming"
expgdd_bbd$agtmin_rel<-expgdd_bbd$agtmin-min(expgdd_bbd$agtmin)
#above-ground temp model
smbbdmod_agtsm<-lmer(doy~agtmin_rel*soilmois_janmar + (1|genus.species)+ (1|site/styear), REML=FALSE, data=expgdd_bbd)
smbbdmod_agtsm2<-lmer(doy~agtmin_rel+soilmois_janmar + (1|genus.species)+ (1|site/styear), REML=FALSE, data=expgdd_bbd)
smbbdmod_agt<-lmer(doy~agtmin_rel + (1|genus.species)+ (1|site/styear), REML=FALSE, data=expgdd_bbd)
bbmodstable<-rbind(round(summary(smbbdmod_targt)$coeff[,1:2],digits=2),round(summary(smbbdmod_agtsm)$coeff[,1:2],digits=2))
bbmodstable
dim(bbmodstable)
rownames(bbmodstable)[4]
rownames(bbmodstable)[6]
rownames(bbmodstable)[4]<-"tmin"
rownames(bbmodstable)[6]<-"tmin*soilmois_janmar"
bbmodstable<-cbind(rownames(bbmodstable),bbmodstable)
rownames(bbmodstable)<-c("target warming model","","tmin*soilmois model","","","")
colnames(bbmodstable)<-c("fixed effect","est.","se")
bbmodstable
rm(list=ls())
options(stringsAsFactors = FALSE)
# Set working directory:
if(length(grep("ailene", getwd()))>0) {setwd("~/git/phenconstraints")}
#load libraries
library(RColorBrewer)
#Read in data:
dat2<-read.csv("analyses/output/growingseason_doy2.csv", header = T)
#calculate start of each phase and interphase durations:
source("analyses/source/phase_start_and_inter_species.R")
#Fit models with a forced slope of 1 through the data (only the intercept can move)
#With forced slope models, we have to calculate R2 by hand, so write
bblo_mod <- lm(fLOstartm ~ 1 + offset(1*fLDstartm)) # Force a slope of 1 through the data
summary(bblo_mod)
#looks like I have to do the R2 by hand!
bblo_ss_tot <- sum((fLOstartm - mean(fLOstartm))^2)
bblo_ss_res <- sum(summary(bblo_mod)$residuals)
bblo_r2 <- 1 - ss_res / ss_tot
bblo_r2 <- 1 - bblo_ss_res / bblo_ss_tot
bblo_r2
#looks like I have to do the R2 by hand!
bblo_ss_tot <- sum((fLOstartm - mean(fLOstartm))^2)
bblo_ss_tot
bblo_ss_res
bblo_ss_res / bblo_ss_tot
bblo_r2 <- 1 - bblo_ss_res / bblo_ss_tot
bblo_r2
#Write a loop to fit model, get interepts, r2, and p vals for all
#make vectors of all prev phases (x variables) and later phases (y variables)
phases=cbind(LDstartm,LOstartm,FLstartm,RFRstartm,SENstartm)
colnames(phases)<-c("LDstartm","LOstartm","FLstartm","RFRstartm","SENstartm")
prev_phase_col=c(1,2,3,4)
late_phase_col=c(2,3,4,5)
mean(fLOstartm
)
fLOstartm - mean(fLOstartm)
summary(bblo_mod)$residuals
var(bblo_mod)
var(fLOstartm,fLDstartm)
aic(bblo_mod)
AIC(bblo_mod)
bblo_reg <- lm(fLOstartm ~ fLDstartm) # standard regression
summary(bblo_reg)
AIC(bblo_reg,bblo_mod)
bblo_int <- lm(fLOstartm ~ 1) # standard regression
AIC(bblo_reg,bblo_mod,bblo_int)
#make blank dataframe for model results
prephase<-latephase<-int<-rse<-c()
y=phases[,late_phase_col[i]]
i=1
j=1
y=phases[,late_phase_col[i]]
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
for(j in 1:i){
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
regmod <- lm(y ~ x ) # fit standard regression
yhat <- predict(forceBmod)
ss_tot <- sum((y - mean(y))^2)
ss_res <- sum((y - yhat)^2)
#Rsq <- 1 - ss_res / ss_tot
latephase<-c(latephase,colnames(phases)[late_phase_col[i]])
prephase<-c(prephase,colnames(phases)[prev_phase_col[j]])
plot(x,y)
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
regmod <- lm(y ~ x ) # fit standard regression
yhat <- predict(forceBmod)
ss_tot <- sum((y - mean(y))^2)
ss_res <- sum((y - yhat)^2)
#Rsq <- 1 - ss_res / ss_tot
latephase<-c(latephase,colnames(phases)[late_phase_col[i]])
prephase<-c(prephase,colnames(phases)[prev_phase_col[j]])
plot(x,y)
abline(a=forceBmod,b=1)
int<-c(int,summary(forceBmod)$coef[1])
rse<-c(rse,summary(forceBmod)$sigma)
#rsq<-c(rsq,Rsq)
forceBmod
abline(a=forceBmod,b=1)
forceBmod$coef,
forceBmod$coef
abline(a=forceBmod$coef,b=1)
#make blank dataframe for model results
prephase<-latephase<-int<-rse<-rsq<-c()
for (i in 1:length(late_phase)){
y=phases[,late_phase_col[i]]
for(j in 1:i){
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
regmod <- lm(y ~ x ) # fit standard regression
yhat <- predict(forceBmod)
ss_tot <- sum((y - mean(y))^2)
ss_res <- sum((y - yhat)^2)
Rsq <- 1 - ss_res / ss_tot
latephase<-c(latephase,colnames(phases)[late_phase_col[i]])
prephase<-c(prephase,colnames(phases)[prev_phase_col[j]])
plot(x,y)
abline(a=forceBmod$coef,b=1)
int<-c(int,summary(forceBmod)$coef[1])
rse<-c(rse,summary(forceBmod)$sigma)
rsq<-c(rsq,Rsq)
#pval<-c(pval,summary(mod)$coef[4])
}
}
#make blank dataframe for model results
prephase<-latephase<-int<-rse<-rsq<-c()
for (i in 1:length(late_phase)){
y=phases[,late_phase_col[i]]
for(j in 1:i){
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
regmod <- lm(y ~ x ) # fit standard regression
yhat <- predict(forceBmod)
ss_tot <- sum((y - mean(y))^2)
ss_res <- sum((y - yhat)^2)
Rsq <- 1 - ss_res / ss_tot
latephase<-c(latephase,colnames(phases)[late_phase_col[i]])
prephase<-c(prephase,colnames(phases)[prev_phase_col[j]])
plot(x,y)
abline(a=forceBmod$coef,b=1)
int<-c(int,summary(forceBmod)$coef[1])
rse<-c(rse,summary(forceBmod)$sigma)
rsq<-c(rsq,Rsq)
#pval<-c(pval,summary(mod)$coef[4])
}
}
phases
prev_phase_col=c(1,2,3,4)
late_phase_col=c(2,3,4,5)
#fit 10 models:
for (i in 1:length(late_phase)){
y=phases[,late_phase_col[i]]
for(j in 1:i){
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
regmod <- lm(y ~ x ) # fit standard regression
yhat <- predict(forceBmod)
ss_tot <- sum((y - mean(y))^2)
ss_res <- sum((y - yhat)^2)
Rsq <- 1 - ss_res / ss_tot
latephase<-c(latephase,colnames(phases)[late_phase_col[i]])
prephase<-c(prephase,colnames(phases)[prev_phase_col[j]])
plot(x,y)
abline(a=forceBmod$coef,b=1)
int<-c(int,summary(forceBmod)$coef[1])
rse<-c(rse,summary(forceBmod)$sigma)
rsq<-c(rsq,Rsq)
#pval<-c(pval,summary(mod)$coef[4])
}
}
##########################################
##Make plots of Later vs. Earlier phases##
########
#Write a loop to fit model, get interepts, r2, and p vals for all
#make vectors of all prev phases (x variables) and later phases (y variables)
phases=cbind(LDstartm,LOstartm,FLstartm,RFRstartm,SENstartm)
colnames(phases)<-c("LDstartm","LOstartm","FLstartm","RFRstartm","SENstartm")
prev_phase_col=c(1,2,3,4)
late_phase_col=c(2,3,4,5)
for (i in 1:length(late_phase_col)){
y=phases[,late_phase_col[i]]
for(j in 1:i){
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
regmod <- lm(y ~ x ) # fit standard regression
yhat <- predict(forceBmod)
ss_tot <- sum((y - mean(y))^2)
ss_res <- sum((y - yhat)^2)
Rsq <- 1 - ss_res / ss_tot
latephase<-c(latephase,colnames(phases)[late_phase_col[i]])
prephase<-c(prephase,colnames(phases)[prev_phase_col[j]])
plot(x,y)
abline(a=forceBmod$coef,b=1)
int<-c(int,summary(forceBmod)$coef[1])
rse<-c(rse,summary(forceBmod)$sigma)
rsq<-c(rsq,Rsq)
#pval<-c(pval,summary(mod)$coef[4])
}
}
prephase<-latephase<-int<-rse<-rsq<-c()
#fit 10 models:
for (i in 1:length(late_phase_col)){
y=phases[,late_phase_col[i]]
for(j in 1:i){
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
regmod <- lm(y ~ x ) # fit standard regression
yhat <- predict(forceBmod)
ss_tot <- sum((y - mean(y))^2)
ss_res <- sum((y - yhat)^2)
Rsq <- 1 - ss_res / ss_tot
latephase<-c(latephase,colnames(phases)[late_phase_col[i]])
prephase<-c(prephase,colnames(phases)[prev_phase_col[j]])
plot(x,y)
abline(a=forceBmod$coef,b=1)
int<-c(int,summary(forceBmod)$coef[1])
rse<-c(rse,summary(forceBmod)$sigma)
rsq<-c(rsq,Rsq)
print(colnames(phases)[late_phase_col[i]],colnames(phases)[prev_phase_col[j]])
print(AIC(forceBmod,Intmod,Bmod,regmod))
#pval<-c(pval,summary(mod)$coef[4])
}
}
print(colnames(phases)[late_phase_col[i]],colnames(phases)[prev_phase_col[j]])
colnames(phases)[late_phase_col[i]]
prephase<-latephase<-int<-rse<-rsq<-c()
#fit 10 models:
for (i in 1:length(late_phase_col)){
y=phases[,late_phase_col[i]]
for(j in 1:i){
x=phases[,j]
forceBmod <- lm(y ~ 1 + offset(1*x)) # Force a slope of 1 through the data
Intmod <- lm(y ~ 1 ) # fit only intercept
Bmod <- lm(y ~ -1+x ) # fit only slope
regmod <- lm(y ~ x ) # fit standard regression
yhat <- predict(forceBmod)
ss_tot <- sum((y - mean(y))^2)
ss_res <- sum((y - yhat)^2)
Rsq <- 1 - ss_res / ss_tot
latephase<-c(latephase,colnames(phases)[late_phase_col[i]])
prephase<-c(prephase,colnames(phases)[prev_phase_col[j]])
plot(x,y)
abline(a=forceBmod$coef,b=1)
int<-c(int,summary(forceBmod)$coef[1])
rse<-c(rse,summary(forceBmod)$sigma)
rsq<-c(rsq,Rsq)
print(colnames(phases)[late_phase_col[i]]); print(colnames(phases)[prev_phase_col[j]])
print(AIC(forceBmod,Intmod,Bmod,regmod))
#pval<-c(pval,summary(mod)$coef[4])
}
}
